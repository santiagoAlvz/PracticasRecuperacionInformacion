<!DOCTYPE HTML>
<html lang="en">
<head>
<title>Source code</title>
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
</head>
<body>
<main role="main">
<div class="sourceContainer">
<pre><span class="sourceLineNo">001</span><a id="line.1">/*</a>
<span class="sourceLineNo">002</span><a id="line.2"> * Licensed to the Apache Software Foundation (ASF) under one or more</a>
<span class="sourceLineNo">003</span><a id="line.3"> * contributor license agreements.  See the NOTICE file distributed with</a>
<span class="sourceLineNo">004</span><a id="line.4"> * this work for additional information regarding copyright ownership.</a>
<span class="sourceLineNo">005</span><a id="line.5"> * The ASF licenses this file to You under the Apache License, Version 2.0</a>
<span class="sourceLineNo">006</span><a id="line.6"> * (the "License"); you may not use this file except in compliance with</a>
<span class="sourceLineNo">007</span><a id="line.7"> * the License.  You may obtain a copy of the License at</a>
<span class="sourceLineNo">008</span><a id="line.8"> *</a>
<span class="sourceLineNo">009</span><a id="line.9"> *     http://www.apache.org/licenses/LICENSE-2.0</a>
<span class="sourceLineNo">010</span><a id="line.10"> *</a>
<span class="sourceLineNo">011</span><a id="line.11"> * Unless required by applicable law or agreed to in writing, software</a>
<span class="sourceLineNo">012</span><a id="line.12"> * distributed under the License is distributed on an "AS IS" BASIS,</a>
<span class="sourceLineNo">013</span><a id="line.13"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</a>
<span class="sourceLineNo">014</span><a id="line.14"> * See the License for the specific language governing permissions and</a>
<span class="sourceLineNo">015</span><a id="line.15"> * limitations under the License.</a>
<span class="sourceLineNo">016</span><a id="line.16"> */</a>
<span class="sourceLineNo">017</span><a id="line.17">package org.apache.lucene.demo;</a>
<span class="sourceLineNo">018</span><a id="line.18"></a>
<span class="sourceLineNo">019</span><a id="line.19">import java.io.BufferedReader;</a>
<span class="sourceLineNo">020</span><a id="line.20">import java.io.IOException;</a>
<span class="sourceLineNo">021</span><a id="line.21">import java.io.InputStream;</a>
<span class="sourceLineNo">022</span><a id="line.22">import java.io.InputStreamReader;</a>
<span class="sourceLineNo">023</span><a id="line.23">import java.nio.charset.StandardCharsets;</a>
<span class="sourceLineNo">024</span><a id="line.24">import java.nio.file.FileVisitResult;</a>
<span class="sourceLineNo">025</span><a id="line.25">import java.nio.file.Files;</a>
<span class="sourceLineNo">026</span><a id="line.26">import java.nio.file.Path;</a>
<span class="sourceLineNo">027</span><a id="line.27">import java.nio.file.Paths;</a>
<span class="sourceLineNo">028</span><a id="line.28">import java.nio.file.SimpleFileVisitor;</a>
<span class="sourceLineNo">029</span><a id="line.29">import java.nio.file.attribute.BasicFileAttributes;</a>
<span class="sourceLineNo">030</span><a id="line.30">import java.util.Date;</a>
<span class="sourceLineNo">031</span><a id="line.31">import org.apache.lucene.analysis.Analyzer;</a>
<span class="sourceLineNo">032</span><a id="line.32">import org.apache.lucene.analysis.standard.StandardAnalyzer;</a>
<span class="sourceLineNo">033</span><a id="line.33">import org.apache.lucene.demo.knn.DemoEmbeddings;</a>
<span class="sourceLineNo">034</span><a id="line.34">import org.apache.lucene.demo.knn.KnnVectorDict;</a>
<span class="sourceLineNo">035</span><a id="line.35">import org.apache.lucene.document.Document;</a>
<span class="sourceLineNo">036</span><a id="line.36">import org.apache.lucene.document.Field;</a>
<span class="sourceLineNo">037</span><a id="line.37">import org.apache.lucene.document.KeywordField;</a>
<span class="sourceLineNo">038</span><a id="line.38">import org.apache.lucene.document.KnnFloatVectorField;</a>
<span class="sourceLineNo">039</span><a id="line.39">import org.apache.lucene.document.LongField;</a>
<span class="sourceLineNo">040</span><a id="line.40">import org.apache.lucene.document.TextField;</a>
<span class="sourceLineNo">041</span><a id="line.41">import org.apache.lucene.index.DirectoryReader;</a>
<span class="sourceLineNo">042</span><a id="line.42">import org.apache.lucene.index.IndexReader;</a>
<span class="sourceLineNo">043</span><a id="line.43">import org.apache.lucene.index.IndexWriter;</a>
<span class="sourceLineNo">044</span><a id="line.44">import org.apache.lucene.index.IndexWriterConfig;</a>
<span class="sourceLineNo">045</span><a id="line.45">import org.apache.lucene.index.IndexWriterConfig.OpenMode;</a>
<span class="sourceLineNo">046</span><a id="line.46">import org.apache.lucene.index.Term;</a>
<span class="sourceLineNo">047</span><a id="line.47">import org.apache.lucene.index.VectorSimilarityFunction;</a>
<span class="sourceLineNo">048</span><a id="line.48">import org.apache.lucene.store.Directory;</a>
<span class="sourceLineNo">049</span><a id="line.49">import org.apache.lucene.store.FSDirectory;</a>
<span class="sourceLineNo">050</span><a id="line.50">import org.apache.lucene.util.IOUtils;</a>
<span class="sourceLineNo">051</span><a id="line.51"></a>
<span class="sourceLineNo">052</span><a id="line.52">/**</a>
<span class="sourceLineNo">053</span><a id="line.53"> * Index all text files under a directory.</a>
<span class="sourceLineNo">054</span><a id="line.54"> *</a>
<span class="sourceLineNo">055</span><a id="line.55"> * &lt;p&gt;This is a command-line application demonstrating simple Lucene indexing. Run it with no</a>
<span class="sourceLineNo">056</span><a id="line.56"> * command-line arguments for usage information.</a>
<span class="sourceLineNo">057</span><a id="line.57"> */</a>
<span class="sourceLineNo">058</span><a id="line.58">public class IndexFiles implements AutoCloseable {</a>
<span class="sourceLineNo">059</span><a id="line.59">  static final String KNN_DICT = "knn-dict";</a>
<span class="sourceLineNo">060</span><a id="line.60"></a>
<span class="sourceLineNo">061</span><a id="line.61">  // Calculates embedding vectors for KnnVector search</a>
<span class="sourceLineNo">062</span><a id="line.62">  private final DemoEmbeddings demoEmbeddings;</a>
<span class="sourceLineNo">063</span><a id="line.63">  private final KnnVectorDict vectorDict;</a>
<span class="sourceLineNo">064</span><a id="line.64"></a>
<span class="sourceLineNo">065</span><a id="line.65">  private IndexFiles(KnnVectorDict vectorDict) throws IOException {</a>
<span class="sourceLineNo">066</span><a id="line.66">    if (vectorDict != null) {</a>
<span class="sourceLineNo">067</span><a id="line.67">      this.vectorDict = vectorDict;</a>
<span class="sourceLineNo">068</span><a id="line.68">      demoEmbeddings = new DemoEmbeddings(vectorDict);</a>
<span class="sourceLineNo">069</span><a id="line.69">    } else {</a>
<span class="sourceLineNo">070</span><a id="line.70">      this.vectorDict = null;</a>
<span class="sourceLineNo">071</span><a id="line.71">      demoEmbeddings = null;</a>
<span class="sourceLineNo">072</span><a id="line.72">    }</a>
<span class="sourceLineNo">073</span><a id="line.73">  }</a>
<span class="sourceLineNo">074</span><a id="line.74"></a>
<span class="sourceLineNo">075</span><a id="line.75">  /** Index all text files under a directory. */</a>
<span class="sourceLineNo">076</span><a id="line.76">  public static void main(String[] args) throws Exception {</a>
<span class="sourceLineNo">077</span><a id="line.77">    String usage =</a>
<span class="sourceLineNo">078</span><a id="line.78">        "java org.apache.lucene.demo.IndexFiles"</a>
<span class="sourceLineNo">079</span><a id="line.79">            + " [-index INDEX_PATH] [-docs DOCS_PATH] [-update] [-knn_dict DICT_PATH]\n\n"</a>
<span class="sourceLineNo">080</span><a id="line.80">            + "This indexes the documents in DOCS_PATH, creating a Lucene index"</a>
<span class="sourceLineNo">081</span><a id="line.81">            + "in INDEX_PATH that can be searched with SearchFiles\n"</a>
<span class="sourceLineNo">082</span><a id="line.82">            + "IF DICT_PATH contains a KnnVector dictionary, the index will also support KnnVector search";</a>
<span class="sourceLineNo">083</span><a id="line.83">    String indexPath = "index";</a>
<span class="sourceLineNo">084</span><a id="line.84">    String docsPath = null;</a>
<span class="sourceLineNo">085</span><a id="line.85">    String vectorDictSource = null;</a>
<span class="sourceLineNo">086</span><a id="line.86">    boolean create = true;</a>
<span class="sourceLineNo">087</span><a id="line.87">    for (int i = 0; i &lt; args.length; i++) {</a>
<span class="sourceLineNo">088</span><a id="line.88">      switch (args[i]) {</a>
<span class="sourceLineNo">089</span><a id="line.89">        case "-index":</a>
<span class="sourceLineNo">090</span><a id="line.90">          indexPath = args[++i];</a>
<span class="sourceLineNo">091</span><a id="line.91">          break;</a>
<span class="sourceLineNo">092</span><a id="line.92">        case "-docs":</a>
<span class="sourceLineNo">093</span><a id="line.93">          docsPath = args[++i];</a>
<span class="sourceLineNo">094</span><a id="line.94">          break;</a>
<span class="sourceLineNo">095</span><a id="line.95">        case "-knn_dict":</a>
<span class="sourceLineNo">096</span><a id="line.96">          vectorDictSource = args[++i];</a>
<span class="sourceLineNo">097</span><a id="line.97">          break;</a>
<span class="sourceLineNo">098</span><a id="line.98">        case "-update":</a>
<span class="sourceLineNo">099</span><a id="line.99">          create = false;</a>
<span class="sourceLineNo">100</span><a id="line.100">          break;</a>
<span class="sourceLineNo">101</span><a id="line.101">        case "-create":</a>
<span class="sourceLineNo">102</span><a id="line.102">          create = true;</a>
<span class="sourceLineNo">103</span><a id="line.103">          break;</a>
<span class="sourceLineNo">104</span><a id="line.104">        default:</a>
<span class="sourceLineNo">105</span><a id="line.105">          throw new IllegalArgumentException("unknown parameter " + args[i]);</a>
<span class="sourceLineNo">106</span><a id="line.106">      }</a>
<span class="sourceLineNo">107</span><a id="line.107">    }</a>
<span class="sourceLineNo">108</span><a id="line.108"></a>
<span class="sourceLineNo">109</span><a id="line.109">    if (docsPath == null) {</a>
<span class="sourceLineNo">110</span><a id="line.110">      System.err.println("Usage: " + usage);</a>
<span class="sourceLineNo">111</span><a id="line.111">      System.exit(1);</a>
<span class="sourceLineNo">112</span><a id="line.112">    }</a>
<span class="sourceLineNo">113</span><a id="line.113"></a>
<span class="sourceLineNo">114</span><a id="line.114">    final Path docDir = Paths.get(docsPath);</a>
<span class="sourceLineNo">115</span><a id="line.115">    if (!Files.isReadable(docDir)) {</a>
<span class="sourceLineNo">116</span><a id="line.116">      System.out.println(</a>
<span class="sourceLineNo">117</span><a id="line.117">          "Document directory '"</a>
<span class="sourceLineNo">118</span><a id="line.118">              + docDir.toAbsolutePath()</a>
<span class="sourceLineNo">119</span><a id="line.119">              + "' does not exist or is not readable, please check the path");</a>
<span class="sourceLineNo">120</span><a id="line.120">      System.exit(1);</a>
<span class="sourceLineNo">121</span><a id="line.121">    }</a>
<span class="sourceLineNo">122</span><a id="line.122"></a>
<span class="sourceLineNo">123</span><a id="line.123">    Date start = new Date();</a>
<span class="sourceLineNo">124</span><a id="line.124">    try {</a>
<span class="sourceLineNo">125</span><a id="line.125">      System.out.println("Indexing to directory '" + indexPath + "'...");</a>
<span class="sourceLineNo">126</span><a id="line.126"></a>
<span class="sourceLineNo">127</span><a id="line.127">      Directory dir = FSDirectory.open(Paths.get(indexPath));</a>
<span class="sourceLineNo">128</span><a id="line.128">      Analyzer analyzer = new StandardAnalyzer();</a>
<span class="sourceLineNo">129</span><a id="line.129">      IndexWriterConfig iwc = new IndexWriterConfig(analyzer);</a>
<span class="sourceLineNo">130</span><a id="line.130"></a>
<span class="sourceLineNo">131</span><a id="line.131">      if (create) {</a>
<span class="sourceLineNo">132</span><a id="line.132">        // Create a new index in the directory, removing any</a>
<span class="sourceLineNo">133</span><a id="line.133">        // previously indexed documents:</a>
<span class="sourceLineNo">134</span><a id="line.134">        iwc.setOpenMode(OpenMode.CREATE);</a>
<span class="sourceLineNo">135</span><a id="line.135">      } else {</a>
<span class="sourceLineNo">136</span><a id="line.136">        // Add new documents to an existing index:</a>
<span class="sourceLineNo">137</span><a id="line.137">        iwc.setOpenMode(OpenMode.CREATE_OR_APPEND);</a>
<span class="sourceLineNo">138</span><a id="line.138">      }</a>
<span class="sourceLineNo">139</span><a id="line.139"></a>
<span class="sourceLineNo">140</span><a id="line.140">      // Optional: for better indexing performance, if you</a>
<span class="sourceLineNo">141</span><a id="line.141">      // are indexing many documents, increase the RAM</a>
<span class="sourceLineNo">142</span><a id="line.142">      // buffer.  But if you do this, increase the max heap</a>
<span class="sourceLineNo">143</span><a id="line.143">      // size to the JVM (eg add -Xmx512m or -Xmx1g):</a>
<span class="sourceLineNo">144</span><a id="line.144">      //</a>
<span class="sourceLineNo">145</span><a id="line.145">      // iwc.setRAMBufferSizeMB(256.0);</a>
<span class="sourceLineNo">146</span><a id="line.146"></a>
<span class="sourceLineNo">147</span><a id="line.147">      KnnVectorDict vectorDictInstance = null;</a>
<span class="sourceLineNo">148</span><a id="line.148">      long vectorDictSize = 0;</a>
<span class="sourceLineNo">149</span><a id="line.149">      if (vectorDictSource != null) {</a>
<span class="sourceLineNo">150</span><a id="line.150">        KnnVectorDict.build(Paths.get(vectorDictSource), dir, KNN_DICT);</a>
<span class="sourceLineNo">151</span><a id="line.151">        vectorDictInstance = new KnnVectorDict(dir, KNN_DICT);</a>
<span class="sourceLineNo">152</span><a id="line.152">        vectorDictSize = vectorDictInstance.ramBytesUsed();</a>
<span class="sourceLineNo">153</span><a id="line.153">      }</a>
<span class="sourceLineNo">154</span><a id="line.154"></a>
<span class="sourceLineNo">155</span><a id="line.155">      try (IndexWriter writer = new IndexWriter(dir, iwc);</a>
<span class="sourceLineNo">156</span><a id="line.156">          IndexFiles indexFiles = new IndexFiles(vectorDictInstance)) {</a>
<span class="sourceLineNo">157</span><a id="line.157">        indexFiles.indexDocs(writer, docDir);</a>
<span class="sourceLineNo">158</span><a id="line.158"></a>
<span class="sourceLineNo">159</span><a id="line.159">        // NOTE: if you want to maximize search performance,</a>
<span class="sourceLineNo">160</span><a id="line.160">        // you can optionally call forceMerge here.  This can be</a>
<span class="sourceLineNo">161</span><a id="line.161">        // a terribly costly operation, so generally it's only</a>
<span class="sourceLineNo">162</span><a id="line.162">        // worth it when your index is relatively static (ie</a>
<span class="sourceLineNo">163</span><a id="line.163">        // you're done adding documents to it):</a>
<span class="sourceLineNo">164</span><a id="line.164">        //</a>
<span class="sourceLineNo">165</span><a id="line.165">        // writer.forceMerge(1);</a>
<span class="sourceLineNo">166</span><a id="line.166">      } finally {</a>
<span class="sourceLineNo">167</span><a id="line.167">        IOUtils.close(vectorDictInstance);</a>
<span class="sourceLineNo">168</span><a id="line.168">      }</a>
<span class="sourceLineNo">169</span><a id="line.169"></a>
<span class="sourceLineNo">170</span><a id="line.170">      Date end = new Date();</a>
<span class="sourceLineNo">171</span><a id="line.171">      try (IndexReader reader = DirectoryReader.open(dir)) {</a>
<span class="sourceLineNo">172</span><a id="line.172">        System.out.println(</a>
<span class="sourceLineNo">173</span><a id="line.173">            "Indexed "</a>
<span class="sourceLineNo">174</span><a id="line.174">                + reader.numDocs()</a>
<span class="sourceLineNo">175</span><a id="line.175">                + " documents in "</a>
<span class="sourceLineNo">176</span><a id="line.176">                + (end.getTime() - start.getTime())</a>
<span class="sourceLineNo">177</span><a id="line.177">                + " ms");</a>
<span class="sourceLineNo">178</span><a id="line.178">        if (reader.numDocs() &gt; 100</a>
<span class="sourceLineNo">179</span><a id="line.179">            &amp;&amp; vectorDictSize &lt; 1_000_000</a>
<span class="sourceLineNo">180</span><a id="line.180">            &amp;&amp; System.getProperty("smoketester") == null) {</a>
<span class="sourceLineNo">181</span><a id="line.181">          throw new RuntimeException(</a>
<span class="sourceLineNo">182</span><a id="line.182">              "Are you (ab)using the toy vector dictionary? See the package javadocs to understand why you got this exception.");</a>
<span class="sourceLineNo">183</span><a id="line.183">        }</a>
<span class="sourceLineNo">184</span><a id="line.184">      }</a>
<span class="sourceLineNo">185</span><a id="line.185">    } catch (IOException e) {</a>
<span class="sourceLineNo">186</span><a id="line.186">      System.out.println(" caught a " + e.getClass() + "\n with message: " + e.getMessage());</a>
<span class="sourceLineNo">187</span><a id="line.187">    }</a>
<span class="sourceLineNo">188</span><a id="line.188">  }</a>
<span class="sourceLineNo">189</span><a id="line.189"></a>
<span class="sourceLineNo">190</span><a id="line.190">  /**</a>
<span class="sourceLineNo">191</span><a id="line.191">   * Indexes the given file using the given writer, or if a directory is given, recurses over files</a>
<span class="sourceLineNo">192</span><a id="line.192">   * and directories found under the given directory.</a>
<span class="sourceLineNo">193</span><a id="line.193">   *</a>
<span class="sourceLineNo">194</span><a id="line.194">   * &lt;p&gt;NOTE: This method indexes one document per input file. This is slow. For good throughput,</a>
<span class="sourceLineNo">195</span><a id="line.195">   * put multiple documents into your input file(s). An example of this is in the benchmark module,</a>
<span class="sourceLineNo">196</span><a id="line.196">   * which can create "line doc" files, one document per line, using the &lt;a</a>
<span class="sourceLineNo">197</span><a id="line.197">   * href="../../../../../contrib-benchmark/org/apache/lucene/benchmark/byTask/tasks/WriteLineDocTask.html"</a>
<span class="sourceLineNo">198</span><a id="line.198">   * &gt;WriteLineDocTask&lt;/a&gt;.</a>
<span class="sourceLineNo">199</span><a id="line.199">   *</a>
<span class="sourceLineNo">200</span><a id="line.200">   * @param writer Writer to the index where the given file/dir info will be stored</a>
<span class="sourceLineNo">201</span><a id="line.201">   * @param path The file to index, or the directory to recurse into to find files to index</a>
<span class="sourceLineNo">202</span><a id="line.202">   * @throws IOException If there is a low-level I/O error</a>
<span class="sourceLineNo">203</span><a id="line.203">   */</a>
<span class="sourceLineNo">204</span><a id="line.204">  void indexDocs(final IndexWriter writer, Path path) throws IOException {</a>
<span class="sourceLineNo">205</span><a id="line.205">    if (Files.isDirectory(path)) {</a>
<span class="sourceLineNo">206</span><a id="line.206">      Files.walkFileTree(</a>
<span class="sourceLineNo">207</span><a id="line.207">          path,</a>
<span class="sourceLineNo">208</span><a id="line.208">          new SimpleFileVisitor&lt;&gt;() {</a>
<span class="sourceLineNo">209</span><a id="line.209">            @Override</a>
<span class="sourceLineNo">210</span><a id="line.210">            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {</a>
<span class="sourceLineNo">211</span><a id="line.211">              try {</a>
<span class="sourceLineNo">212</span><a id="line.212">                indexDoc(writer, file, attrs.lastModifiedTime().toMillis());</a>
<span class="sourceLineNo">213</span><a id="line.213">              } catch (</a>
<span class="sourceLineNo">214</span><a id="line.214">                  @SuppressWarnings("unused")</a>
<span class="sourceLineNo">215</span><a id="line.215">                  IOException ignore) {</a>
<span class="sourceLineNo">216</span><a id="line.216">                ignore.printStackTrace(System.err);</a>
<span class="sourceLineNo">217</span><a id="line.217">                // don't index files that can't be read.</a>
<span class="sourceLineNo">218</span><a id="line.218">              }</a>
<span class="sourceLineNo">219</span><a id="line.219">              return FileVisitResult.CONTINUE;</a>
<span class="sourceLineNo">220</span><a id="line.220">            }</a>
<span class="sourceLineNo">221</span><a id="line.221">          });</a>
<span class="sourceLineNo">222</span><a id="line.222">    } else {</a>
<span class="sourceLineNo">223</span><a id="line.223">      indexDoc(writer, path, Files.getLastModifiedTime(path).toMillis());</a>
<span class="sourceLineNo">224</span><a id="line.224">    }</a>
<span class="sourceLineNo">225</span><a id="line.225">  }</a>
<span class="sourceLineNo">226</span><a id="line.226"></a>
<span class="sourceLineNo">227</span><a id="line.227">  /** Indexes a single document */</a>
<span class="sourceLineNo">228</span><a id="line.228">  void indexDoc(IndexWriter writer, Path file, long lastModified) throws IOException {</a>
<span class="sourceLineNo">229</span><a id="line.229">    try (InputStream stream = Files.newInputStream(file)) {</a>
<span class="sourceLineNo">230</span><a id="line.230">      // make a new, empty document</a>
<span class="sourceLineNo">231</span><a id="line.231">      Document doc = new Document();</a>
<span class="sourceLineNo">232</span><a id="line.232"></a>
<span class="sourceLineNo">233</span><a id="line.233">      // Add the path of the file as a field named "path".  Use a</a>
<span class="sourceLineNo">234</span><a id="line.234">      // field that is indexed (i.e. searchable), but don't tokenize</a>
<span class="sourceLineNo">235</span><a id="line.235">      // the field into separate words and don't index term frequency</a>
<span class="sourceLineNo">236</span><a id="line.236">      // or positional information:</a>
<span class="sourceLineNo">237</span><a id="line.237">      doc.add(new KeywordField("path", file.toString(), Field.Store.YES));</a>
<span class="sourceLineNo">238</span><a id="line.238"></a>
<span class="sourceLineNo">239</span><a id="line.239">      // Add the last modified date of the file a field named "modified".</a>
<span class="sourceLineNo">240</span><a id="line.240">      // Use a LongField that is indexed with points and doc values, and is efficient</a>
<span class="sourceLineNo">241</span><a id="line.241">      // for both filtering (LongField#newRangeQuery) and sorting</a>
<span class="sourceLineNo">242</span><a id="line.242">      // (LongField#newSortField).  This indexes to milli-second resolution, which</a>
<span class="sourceLineNo">243</span><a id="line.243">      // is often too fine.  You could instead create a number based on</a>
<span class="sourceLineNo">244</span><a id="line.244">      // year/month/day/hour/minutes/seconds, down the resolution you require.</a>
<span class="sourceLineNo">245</span><a id="line.245">      // For example the long value 2011021714 would mean</a>
<span class="sourceLineNo">246</span><a id="line.246">      // February 17, 2011, 2-3 PM.</a>
<span class="sourceLineNo">247</span><a id="line.247">      doc.add(new LongField("modified", lastModified, Field.Store.NO));</a>
<span class="sourceLineNo">248</span><a id="line.248"></a>
<span class="sourceLineNo">249</span><a id="line.249">      // Add the contents of the file to a field named "contents".  Specify a Reader,</a>
<span class="sourceLineNo">250</span><a id="line.250">      // so that the text of the file is tokenized and indexed, but not stored.</a>
<span class="sourceLineNo">251</span><a id="line.251">      // Note that FileReader expects the file to be in UTF-8 encoding.</a>
<span class="sourceLineNo">252</span><a id="line.252">      // If that's not the case searching for special characters will fail.</a>
<span class="sourceLineNo">253</span><a id="line.253">      doc.add(</a>
<span class="sourceLineNo">254</span><a id="line.254">          new TextField(</a>
<span class="sourceLineNo">255</span><a id="line.255">              "contents",</a>
<span class="sourceLineNo">256</span><a id="line.256">              new BufferedReader(new InputStreamReader(stream, StandardCharsets.UTF_8))));</a>
<span class="sourceLineNo">257</span><a id="line.257"></a>
<span class="sourceLineNo">258</span><a id="line.258">      if (demoEmbeddings != null) {</a>
<span class="sourceLineNo">259</span><a id="line.259">        try (InputStream in = Files.newInputStream(file)) {</a>
<span class="sourceLineNo">260</span><a id="line.260">          float[] vector =</a>
<span class="sourceLineNo">261</span><a id="line.261">              demoEmbeddings.computeEmbedding(</a>
<span class="sourceLineNo">262</span><a id="line.262">                  new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8)));</a>
<span class="sourceLineNo">263</span><a id="line.263">          doc.add(</a>
<span class="sourceLineNo">264</span><a id="line.264">              new KnnFloatVectorField(</a>
<span class="sourceLineNo">265</span><a id="line.265">                  "contents-vector", vector, VectorSimilarityFunction.DOT_PRODUCT));</a>
<span class="sourceLineNo">266</span><a id="line.266">        }</a>
<span class="sourceLineNo">267</span><a id="line.267">      }</a>
<span class="sourceLineNo">268</span><a id="line.268"></a>
<span class="sourceLineNo">269</span><a id="line.269">      if (writer.getConfig().getOpenMode() == OpenMode.CREATE) {</a>
<span class="sourceLineNo">270</span><a id="line.270">        // New index, so we just add the document (no old document can be there):</a>
<span class="sourceLineNo">271</span><a id="line.271">        System.out.println("adding " + file);</a>
<span class="sourceLineNo">272</span><a id="line.272">        writer.addDocument(doc);</a>
<span class="sourceLineNo">273</span><a id="line.273">      } else {</a>
<span class="sourceLineNo">274</span><a id="line.274">        // Existing index (an old copy of this document may have been indexed) so</a>
<span class="sourceLineNo">275</span><a id="line.275">        // we use updateDocument instead to replace the old one matching the exact</a>
<span class="sourceLineNo">276</span><a id="line.276">        // path, if present:</a>
<span class="sourceLineNo">277</span><a id="line.277">        System.out.println("updating " + file);</a>
<span class="sourceLineNo">278</span><a id="line.278">        writer.updateDocument(new Term("path", file.toString()), doc);</a>
<span class="sourceLineNo">279</span><a id="line.279">      }</a>
<span class="sourceLineNo">280</span><a id="line.280">    }</a>
<span class="sourceLineNo">281</span><a id="line.281">  }</a>
<span class="sourceLineNo">282</span><a id="line.282"></a>
<span class="sourceLineNo">283</span><a id="line.283">  @Override</a>
<span class="sourceLineNo">284</span><a id="line.284">  public void close() throws IOException {</a>
<span class="sourceLineNo">285</span><a id="line.285">    IOUtils.close(vectorDict);</a>
<span class="sourceLineNo">286</span><a id="line.286">  }</a>
<span class="sourceLineNo">287</span><a id="line.287">}</a>




























































</pre>
</div>
</main>
</body>
</html>
